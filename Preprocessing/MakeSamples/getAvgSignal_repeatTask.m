%% Get average signal in each trial of shapedim repeat detection (one-back) task
% This script generates a structure array nROIs long, with each element
% containing a structure that includes fields for the task data [nTrials x
% nVoxels] and labels [nTrials x 1] for what was happening on each trial of
% the task. 
% Data are averaged within a specific time window after stim onset in each
% trial (specified by avgTRs_targ in code)
% Also creates time-resolved (i.e. epoched) array which is [nTrials x nTRs
% x nVoxels] in size, for each ROI.
% All the ROIs used here are bilateral (combining LH/RH)
% Loads the file generated by MakeSampleFile
%%
clear

sublist = [1,2,3,4,5,6,7];
% find my root directory - up a few dirs from where i am now
mypath = pwd;
filesepinds = find(mypath==filesep);
nDirsUp = 2;
exp_path = mypath(1:filesepinds(end-nDirsUp+1));

%% params here
trDur = .8; % actual duration of the TR, for plotting, in seconds...
nTRs = 329-16;

ROI_names = {'V1','V2','V3','V3AB','hV4','IPS0','IPS1','IPS2','IPS3','LO1','LO2'};
% ROI_names = {'V1','V2','V3','V3AB','hV4','IPS0','IPS1','IPS2','IPS3','LO1','LO2',...
%     'IFS', 'AI-FO', 'iPCS', 'sPCS','sIPS','ACC-preSMA'};

nROIs = length(ROI_names);

% which TRs am i averaging over? From the target onset time.
avgTRs_targ = [4,7];

% how many TRs to use for TR-by-TR analyses?
nTRs2concat = 14;

nTrialsPerRun=48;
nRunsExpected=12;
    
%% load data    
for ss = sublist

    repSig = struct();

    substr = sprintf('S%02d',ss);
   
    fn2load = fullfile(exp_path,'Samples',sprintf('SampleFile_%s.mat',substr));
    load(fn2load, 'samplesRep','ROIs','all_vox_concat');
    
    %% load the timing file (made in GetEventTiming.m)
    
    fn = fullfile(exp_path,'Samples',sprintf('TimingFile_%s.mat',substr));
    if ~exist(fn, 'file')
        error('need to make timing file first, run GetEventTiming.m')
    end
    fprintf('Loading event timing file\n')
    load(fn)
    
    % double check i have the right total number of TRs across these
    assert(size(samplesRep,1)==length(rep.RunLabels))
    
    
    fn2save = fullfile(exp_path,'Samples',sprintf('RepeatTaskSignalByTrial_%s.mat',substr));    
   
    %%
    for vv = 1:nROIs % for all visual areas I want to look at
        %% pull out the data from each ROI
        % want both hemispheres
        [rowind1,colind1] = find(strcmp(reshape({ROIs.name},2,nROIs),sprintf('lh_%s',ROI_names{vv})));
        [rowind2,colind2] = find(strcmp(reshape({ROIs.name},2,nROIs),sprintf('rh_%s',ROI_names{vv})));
        col_inds = [colind1,colind2]; % column is the region
        row_inds = [rowind1,rowind2];   % row is the hemisphere
        
        % make sure each visual area is defined for both hemispheres.
        assert(numel(col_inds)==2)
        
        repDat=[]; 
        eccVals = [];
        for ii=1:length(col_inds)
            name = ROIs(row_inds(ii),col_inds(ii)).name;
            if ~isempty(ROIs(row_inds(ii),col_inds(ii)).voxel_inds)
                % jj gives indices into the all_vox_concat array
                [~,jj]=intersect(all_vox_concat, ROIs(row_inds(ii),col_inds(ii)).voxel_inds);
                repDat = [repDat, samplesRep(:,jj)];
            end
        end
        nVox = size(repDat,2);

        if nVox==0
            fprintf('no voxels in area %s!\n',ROI_names{vv});
            continue
        end

        fprintf('processing area %s, %d voxels\n', ROI_names{vv}, nVox);
        
        %% now zscore the data from each run to normalize...

        nRuns = size(repDat,1)/nTRs;
        if nRuns~=nRunsExpected
            fprintf('warning: you only have %d/%d runs for %s\n', nRuns, nRunsExpected, substr)
        end
        assert(nRuns==length(unique(rep.RunLabels)))
        if mod(nRuns,1)~=0
            error('something bad happened here with repDat run length')
        end
        for ii=1:nRuns
            repDat(ii*nTRs-nTRs+1:ii*nTRs,:) = zscore(repDat(ii*nTRs-nTRs+1:ii*nTRs, :),1);
        end
        
        assert(numel(unique(rep.RunLabels))==nRuns);
        %% label the data
        % 1 = stim on, 0 = stim off
        event_diff_reshaped = reshape(diff([0;rep.EventLabels]),nTRs,length(rep.EventLabels)/nTRs);

        % now find the actual onset of each stimulus - switch from 0.2 to 1
        % (or 0 to 1)
        trial_onset_bool = event_diff_reshaped==1;
        trial_onset_bool = trial_onset_bool(:);
        trial_onset_num = find(trial_onset_bool);
                
        nTrials = nRuns*nTrialsPerRun;
        assert(numel(trial_onset_num)==nTrials);
        
        %% save out a bunch of descriptors for the trials
        
        repSig(vv).RunLabels = rep.RunLabels(trial_onset_num);
        repSig(vv).TrialLabels = rep.TrialLabels(trial_onset_num);
        repSig(vv).SessLabels = rep.SessLabels(trial_onset_num);

        repSig(vv).PointLabels = rep.PointLabels(trial_onset_num,:);
        repSig(vv).MapLabels = rep.MapLabels(trial_onset_num);
        repSig(vv).IsMainLabels = rep.IsMainLabels(trial_onset_num);
        repSig(vv).IsRepeatLabels = rep.IsRepeatLabels(trial_onset_num);
        repSig(vv).DistLabels = rep.DistLabels(trial_onset_num);
        repSig(vv).RunDiffLabels = rep.RunDiffLabels(trial_onset_num);

        repSig(vv).RTLabels = rep.RTLabels(trial_onset_num);
        repSig(vv).ResponseLabels = rep.ResponseLabels(trial_onset_num);

        %% avg the data across each trial
        % single value for each trial, averaged over multiple TRs
        dat_avg_targ = nan(nTrials, nVox); 
      
        % TR-by-TR data        
        dat_by_TR = nan(nTrials, nTRs2concat, nVox);
        
        triCnt = 0; % counter across "good" trials where the entire desired avg window is available.
    
        for rr=1:nRuns

            runInd = rr*nTRs-nTRs+1:rr*nTRs;
            assert(all(find(rep.RunLabels==rr)==runInd'))
            curDat = repDat(runInd,:);      % data from current run

            % get numeric indices for each event in this run
            these_targ_onsets = find(trial_onset_bool(runInd));                   
          
            
            assert(numel(these_targ_onsets)==nTrialsPerRun);
            
            for tt=1:numel(these_targ_onsets)
                % check to make sure we don't go past the end of the run.
                if these_targ_onsets(tt)+nTRs2concat<=nTRs
               
                    triCnt = triCnt + 1;  % increment counter over good trials

                    % sum the data over desired interval.
                    dat_avg_targ(triCnt,:) = mean(curDat(these_targ_onsets(tt)+avgTRs_targ(1):these_targ_onsets(tt)+avgTRs_targ(2),:));
                   
                end
                
                % also collecting data at each timept
                for tr = 1:nTRs2concat
                    if these_targ_onsets(tt)+tr-1<=nTRs 
                        dat_by_TR(triCnt,tr,:) = curDat(these_targ_onsets(tt)+tr-1,:);
                    else
                        error('TR %d is past the end of your run!!', tr)
                    end
                end
            end
        end

        assert(triCnt==nTrials)
        assert(~sum(isnan(dat_avg_targ(:))) && ~sum(isnan(dat_by_TR(:))))
       
        repSig(vv).dat_avg = dat_avg_targ;
        
        % this matrix is [nTrials x nTRs x nVox]
        repSig(vv).dat_by_TR = dat_by_TR;

    end

    fprintf('saving to %s\n',fn2save);
    save(fn2save,'repSig','ROI_names','-v7.3');

end